#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>
#include <semaphore.h>

#include "../common/common.h"
#include "../common/cdf.h"
#include "../common/conn.h"
#include "../common/queue.h"
#include "../sequencer/udp_conn.h"

#include "../cAPI/sim.h"

// #define DEBUG
#define DEBUG2
// #define LOGGING


struct fs_info{
	int flowID;
	int flowClass;
	int flowSize;
};


struct fs_info *fs_info_list;

bool verbose_mode = false;  /* by default, we don't give more detailed output */

char config_file_name[80] = {0};    /* configuration file */
char dist_file_name[80] = {0};  /* flow size distribution file */
char fct_log_name[80] = "flows.txt";    /* default log file */
int seed = 0;   /* random seed */
char result_script_name[80] = {0};  /* script file to parse final results */
unsigned int usleep_overhead_us = 0;    /* usleep overhead in microsecond */
struct timeval tv_start, tv_end;    /* start and end time of traffic */
unsigned int num_new_conn = 0;  /* new established connections */

/* per-server variables */
unsigned int num_server = 0;    /* total number of servers */
unsigned int *server_port = NULL;   /* ports of servers */
char (*server_addr)[20] = NULL; /* IP addresses of servers */
unsigned int *server_req_count = NULL;  /* numbers of flows generated by different servers */

unsigned int num_dscp = 0;  /* number of DSCP */
unsigned int *dscp_value = NULL;
unsigned int *dscp_prob = NULL;
unsigned int dscp_prob_total = 0;

unsigned int num_rate = 0;  /* number of sending rates */
unsigned int *rate_value = NULL;
unsigned int *rate_prob = NULL;
unsigned int rate_prob_total = 0;

double load = -1;   /* network load (Mbps) */
unsigned int req_total_num = 0; /* total number of requests to generate */
unsigned int req_total_time = 0;    /* total time to generate requests (in seconds) */
struct cdf_table *req_size_dist = NULL;
unsigned int period_us; /* average request arrival interval (in microseconds) */

/* per-request variables */
unsigned int *req_size = NULL;  /* flow size (in bytes) */
unsigned int *req_server_id = NULL; /* server ID */
unsigned int *req_dscp = NULL;  /* DSCP of flow */
unsigned int *req_rate = NULL;  /* sending rate of flow */
unsigned int *req_sleep_us = NULL;
unsigned int *req_done = NULL;  /* if done or not */
unsigned int *req_seq = NULL; /* seq given by sequencer */
unsigned long long *req_pause_us = NULL;
struct timeval *req_start_time; /* start time of flow */
struct timeval *req_stop_time;  /* stop time of flow */
struct timeval *req_dispatch_time;  /* dispatch time of a flow request */

struct conn_list *connection_lists = NULL;  /* connection pool */
int scheme=1;  /* default scheme is FIFO */


/* Scheduler vars */
struct Queue *dispatch_queues = NULL;
sem_t *class_busy_mutex = NULL;
pthread_t *schedulers = NULL;

/* Broadcast listener vars */
struct Queue *sequencing_queues = NULL;
pthread_t broadcast_manager;

// thresholds for class
unsigned int num_classes = 1;
unsigned int *thresholds = NULL;
unsigned int tos_map[] = {4,32,40,56,72,128,152,184,192,224};

/* Monitoring requests */
unsigned int req_generated = 0;
unsigned int req_completed = 0;

/* Sequencer vars */
unsigned long long avg_seq_overhead = 0;
bool use_seq = false; /* default is not to use sequencer */
struct conn_list sequencer_conns;
unsigned int seq_port = TG_SEQ_PORT;   /* port of sequencer */
char seq_addr[20] = "127.0.0.1"; /* IP address of sequencer */

/* batching functions */
unsigned int get_batch_size(unsigned int flowsize);
unsigned int max_batch_size = 100000;
bool use_batching=true;

/* udp connection vars */
int send_fd, recv_fd;

/* controller queues */
queue *controller_queue=NULL;

/* logging */
char syslog[80] = "outs.log"; /* logfile for activity tracing */
FILE *log_fd;

/* function declarations */
void print_classes();
int get_class(int size);
int get_tos(int size);
void set_class_variables();
/* print usage of the program */
void print_usage(char *program);
/* read command line arguments */
void read_args(int argc, char *argv[]);
/* read configuration file */
void read_config(char *file_name);
/* set request variables */
void set_req_variables();
/* receive traffic from established connections */
void *listen_connection(void *ptr);
/* generate flow requests */
void run_requests();
/* generate a flow request to the server - worker*/
void run_request(unsigned int req_id);

/* threaded routines for  */
void *run_scheduler(void *ptr);
void *run_broadcast_manager(void *ptr);

/* initializing functions */
bool init_schedulers();
bool init_broadcast_manager();
void init_seq_conns();

/* terminate all existing connections */
void exit_connections();
/* terminate a connection */
void exit_connection(struct conn_node *node);
/* print statistic data */
void print_statistic();
/* clean up resources */
void cleanup();
/* get sequence number from sequencer */
bool get_seq(unsigned int req_id, struct seq_msg *smsg);
/* set request variables from file*/
void set_req_variables_file(char *file_name);
/* flow classifier */
void classify_flow(unsigned int id);
/* controller */
void *controller_routine(void *args);
void *controller_send_routine(void *args);

int main(int argc, char *argv[])
{



	fs_info_list=malloc(1000000*sizeof(struct fs_info));

    /* setup UDP socket for SEQ msg broadcast and bind to it */
    /* setup logfile */
    log_fd = fopen(syslog,"w");
    
    if(use_seq){
        printf("recv socket successful: %d\n",init_UDP_socket(&recv_fd, -1, true, true));
        printf("send socket successful: %d\n",init_UDP_socket(&send_fd, -1, false, true));
        printf("Broadcasting socket: %d\n", send_fd);
        printf("Listening socket: %d\n", recv_fd);
    }
        

    unsigned int i = 0;
    struct conn_node *ptr = NULL;

    /* read program arguments */
    read_args(argc, argv);

    /* set seed value for random number generation */
    if (seed == 0)
    {
        gettimeofday(&tv_start, NULL);
        srand((tv_start.tv_sec*1000000) + tv_start.tv_usec);
    }
    else
        srand(seed);

    /* calculate usleep overhead */
    usleep_overhead_us = get_usleep_overhead(20);

    /* read configuration file */
    read_config(config_file_name);


    /* set request variables */
    set_req_variables();

    /* set req file */
    // set_req_variables_file("flow_schedule.tr");


    // #ifdef DEBUG2
    // #endif

    for(i=0; i<num_classes-1;i++){
        printf("Threshold %d: %u\n", i,thresholds[i]);
    }
    printf("Number of classes: %d\n",num_classes);
    

    /* initialize controller queue */
    controller_queue=malloc(sizeof(queue));
    queue_init(controller_queue,sizeof(unsigned int));
    pthread_t thread_tmp[2];
    pthread_create(&thread_tmp[0], NULL, controller_routine, NULL);
    pthread_create(&thread_tmp[1], NULL, controller_send_routine, NULL);

    printf("successfully initialized controller queue\n");

    if (verbose_mode)
    {
        printf("===========================================\n");
        printf("The usleep overhead is %u us\n", usleep_overhead_us);
        printf("===========================================\n");
    }

    /* we use calloc here to implicitly initialize struct conn_list as 0 */
    connection_lists = (struct conn_list*)calloc(num_server, sizeof(struct conn_list));


    /* initializing broadcast manager thread vars */
    if(use_seq){
        if(!init_broadcast_manager()) {
            cleanup();
            error("Error: can't initialize threads");
        }
        init_seq_conns();
    }

    /* initializing scheduler thread vars */
    if(!init_schedulers()) {
        cleanup();
        error("Error: can't initialize threads");
    }    
    
    if (!connection_lists)
    {
        cleanup();
        error("Error: calloc connection_lists");
    }

    /* initialize connection pool and establish connections to servers */
    for (i = 0; i < num_server; i++)
    {
        /* initialize server IP and port information */
        if (!init_conn_list(&connection_lists[i], i, server_addr[i], server_port[i]))
        {
            cleanup();
            error("Error: init_conn_list");
        }
        /* establish TG_PAIR_INIT_CONN connections to server_addr[i]:server_port[i] */
        if (!insert_conn_list(&connection_lists[i], num_classes))
        {
            cleanup();
            error("Error: insert_conn_list");
        }
    }

    /* start threads to receive traffic */
    for (i = 0; i < num_server; i++)
    {
        ptr = connection_lists[i].head;
        while (true)
        {
            if (!ptr)
                break;
            else
            {
                pthread_create(&(ptr->thread), NULL, listen_connection, (void*)ptr);
                ptr = ptr->next;
            }
        }
    }


    


    printf("===========================================\n");
    printf("Start to generate requests\n");
    printf("===========================================\n");
    gettimeofday(&tv_start, NULL);
    run_requests();


    while(req_completed != req_generated){
        // printf("Length of dispatch queue: %d\n", len(&dispatch_queues[0]));
        // printf("Length of sequencing queue: %d\n", len(&sequencing_queues[0]));
        printf("Requests completed: %u Progress: %u%%\n",req_completed,(100*req_completed)/req_generated);
        // printf("============================\n");
        sleep(3);
    }

    // printf("Q1:%d\tQ2:%d\tQ3:%d\n", isEmpty(&queues[0]),isEmpty(&queues[1]),isEmpty(&queues[2]));

    /* close existing connections */
    printf("===========================================\n");
    printf("Exit connections\n");
    printf("===========================================\n");
    exit_connections();
    gettimeofday(&tv_end, NULL);

    printf("===========================================\n");
    for (i = 0; i < num_server; i++)
        print_conn_list(&connection_lists[i]);
    printf("===========================================\n");
    print_statistic();

    /* release resources */
    cleanup();

    /* parse results */
    if (strlen(result_script_name) > 0)
    {
        printf("===========================================\n");
        printf("Flow completion times (FCT) results\n");
        printf("===========================================\n");
        char cmd[180] = {0};
        sprintf(cmd, "python %s %s", result_script_name, fct_log_name);
        system(cmd);
    }

    fclose(log_fd);
    return 0;
}


//HM_Debug: Controller Routine Here
void *controller_routine(void *args){
    initialize("10.1.1.28",50011,controller_queue,thresholds);
}

void *controller_send_routine(void *args){
	while(1){
		sendLoadStats();
		sendFlowStats();
		sleep(1);
	}
	
}

/* print usage of the program */
void print_usage(char *program)
{
    printf("Usage: %s [options]\n", program);
    printf("-b <bandwidth>  expected average RX bandwidth in Mbits/sec\n");
    printf("-c <file>       configuration file (required)\n");
    printf("-n <number>     number of requests (instead of -t)\n");
    printf("-t <time>       time in seconds (instead of -n)\n");
    printf("-l <file>       log file with flow completion times (default %s)\n", fct_log_name);
    printf("-s <seed>       seed to generate random numbers (default current time)\n");
    printf("-r <file>       python script to parse result files\n");
    printf("-v              give more detailed output (verbose)\n");
    printf("-h              display help information\n");
    printf("-z              scheduling policy 1=fifo,2=ps,3=2D\n");
}

/* read command line arguments */
void read_args(int argc, char *argv[])
{
    int i = 1;
    bool error = false;

    if (argc == 1)
    {
        print_usage(argv[0]);
        exit(EXIT_SUCCESS);
    }

    while (i < argc)
    {
        if (strlen(argv[i]) == 2 && strcmp(argv[i], "-b") == 0)
        {
            if (i+1 < argc)
            {
                load = atof(argv[i+1]);
                if (load <= 0)
                {
                    printf("Invalid average RX bandwidth: %f\n", load);
                    print_usage(argv[0]);
                    exit(EXIT_FAILURE);
                }
                i += 2;
            }
            else
            {
                printf("Cannot read average RX bandwidth\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-c") == 0)
        {
            if (i+1 < argc && strlen(argv[i+1]) < sizeof(config_file_name))
            {
                sprintf(config_file_name, "%s", argv[i+1]);
                i += 2;
            }
            else
            {
                printf("Cannot read configuration file name\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-n") == 0)
        {
            if (i+1 < argc)
            {
                req_total_num = (unsigned int)strtoul(argv[i+1], NULL, 10);
                i += 2;
            }
            else
            {
                printf("Cannot read number of requests\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-t") == 0)
        {
            if (i+1 < argc)
            {
                req_total_time = (unsigned int)strtoul(argv[i+1], NULL, 10);
                i += 2;
            }
            else
            {
                printf("Cannot read time to generate requests\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-l") == 0)
        {
            if (i+1 < argc && strlen(argv[i+1]) < sizeof(fct_log_name))
            {
                sprintf(fct_log_name, "%s", argv[i+1]);
                i += 2;
            }
            else
            {
                printf("Cannot read log file name\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-s") == 0)
        {
            if (i+1 < argc)
            {
                seed = atoi(argv[i+1]);
                i += 2;
            }
            else
            {
                printf("Cannot read seed value\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-z") == 0)
        {
            if (i+1 < argc)
            {
                scheme = atoi(argv[i+1]);

                if(scheme > 3 || scheme < 1){
                    printf("Cannot read scheme value\n");
                    exit(EXIT_FAILURE);  
                }

                i += 2;
            }
            else
            {
                printf("Cannot read scheme value\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-r") == 0)
        {
            if (i+1 < argc && strlen(argv[i+1]) < sizeof(result_script_name))
            {
                sprintf(result_script_name, "%s", argv[i+1]);
                i += 2;
            }
            else
            {
                printf("Cannot read script file name\n");
                print_usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-v") == 0)
        {
            verbose_mode = true;
            i++;
        }
        else if (strlen(argv[i]) == 2 && strcmp(argv[i], "-h") == 0)
        {
            print_usage(argv[0]);
            exit(EXIT_SUCCESS);
        }
        else if (strlen(argv[i]) == 4 && strcmp(argv[i],"-seq") == 0)
        {
            use_seq = (bool)(atoi(argv[i+1]));
            printf("use_seq: %d\n", use_seq);
            i += 2;
        }
        else
        {
            printf("Invalid option %s\n", argv[i]);
            print_usage(argv[0]);
            exit(EXIT_FAILURE);
        }
    }

    if (load < 0)
    {
        printf("You need to specify the average RX bandwidth (-b)\n");
        error = true;
    }

    if (req_total_num == 0 && req_total_time == 0)
    {
        printf("You need to specify either the number of requests (-n) or the time to generate requests (-t)\n");
        error = true;
    }
    else if (req_total_num > 0 && req_total_time > 0)
    {
        printf("You cannot specify both the number of requests (-n) and the time to generate requests (-t)\n");
        error = true;
    }

    if (error)
    {
        print_usage(argv[0]);
        exit(EXIT_FAILURE);
    }
}

/* read configuration file */
void read_config(char *file_name)
{
    FILE *fd = NULL;
    char key[80] = {0};
    char line[256] = {0};
    num_server = 0; /* number of senders */
    unsigned int num_dist = 0;  /* number of flow size distributions */
    num_dscp = 0;   /* number of DSCP (optional) */
    num_rate = 0;   /* number of sending rates (optional) */

    printf("===========================================\n");
    printf("Reading configuration file %s\n", file_name);
    printf("===========================================\n");

    /* parse configuration file for the first time */
    fd = fopen(file_name, "r");
    if (!fd)
        error("Error: open configuration file for the first time");

    while (fgets(line, sizeof(line), fd) != NULL)
    {
        sscanf(line, "%s", key);
        if (!strcmp(key, "server"))
            num_server++;
        else if (!strcmp(key, "req_size_dist"))
            num_dist++;
        else if (!strcmp(key, "dscp"))
            num_dscp++;
        else if (!strcmp(key, "rate"))
            num_rate++;
        else if(!strcmp(key, "threshold"))
            num_classes++;
    }

    fclose(fd);

    if (num_server < 1)
        error("Error: configuration file should provide at least one server");
    if (num_dist != 1)
        error("Error: configuration file should provide exactly one request size distribution");

    /* initialize configuration */
    /* per-server variables */
    server_port = (unsigned int*)calloc(num_server, sizeof(unsigned int));
    server_addr = (char (*)[20])calloc(num_server, sizeof(char[20]));
    server_req_count = (unsigned int*)calloc(num_server, sizeof(unsigned int));
    /* DSCP and probability */
    dscp_value = (unsigned int*)calloc(max(num_dscp, 1), sizeof(unsigned int));
    dscp_prob = (unsigned int*)calloc(max(num_dscp, 1), sizeof(unsigned int));
    /* sending rate value and probability */
    rate_value = (unsigned int*)calloc(max(num_rate, 1), sizeof(unsigned int));
    rate_prob = (unsigned int*)calloc(max(num_rate, 1), sizeof(unsigned int));
    thresholds = (unsigned int*)calloc(max(num_classes-1, 1), sizeof(unsigned int));
    //thresholds = (unsigned int*)calloc(max(10, 1), sizeof(unsigned int));

    if (!server_port || !server_addr || !server_req_count || !dscp_value || !dscp_prob || !rate_value || !rate_prob || !thresholds)
    {
        cleanup();
        error("Error: calloc per-server variables");
    }

    /* second time */
    num_server = 0;
    num_dscp = 0;
    num_rate = 0;
    num_classes=1;

    fd = fopen(file_name, "r");
    if (!fd)
    {
        cleanup();
        error("Error: open configuration file for the second time");
    }

    while (fgets(line, sizeof(line), fd) != NULL)
    {
        remove_newline(line);
        sscanf(line, "%s", key);

        if (!strcmp(key, "server"))
        {
            sscanf(line, "%s %s %u", key, server_addr[num_server], &server_port[num_server]);
            if (verbose_mode)
                printf("Server[%u]: %s, Port: %u\n", num_server, server_addr[num_server], server_port[num_server]);
            num_server++;
        }
        else if (!strcmp(key, "sequencer"))
        {
            sscanf(line, "%s %s %*u", key, seq_addr);
        }
        else if (!strcmp(key, "req_size_dist"))
        {
            sscanf(line, "%s %s", key, dist_file_name);
            if (verbose_mode)
                printf("Loading request size distribution: %s\n", dist_file_name);

            req_size_dist = (struct cdf_table*)malloc(sizeof(struct cdf_table));
            if (!req_size_dist)
            {
                cleanup();
                error("Error: malloc req_size_dist");
            }

            init_cdf(req_size_dist);
            set_interpolation(req_size_dist,1);
            load_cdf(req_size_dist, dist_file_name);
            if (verbose_mode)
            {
                printf("===========================================\n");
                print_cdf(req_size_dist);
                printf("Average request size: %.2f bytes\n", avg_cdf(req_size_dist));
                printf("===========================================\n");
            }
        }
        else if (!strcmp(key, "dscp"))
        {
            sscanf(line, "%s %u %u", key, &dscp_value[num_dscp], &dscp_prob[num_dscp]);
            if (dscp_value[num_dscp] < 0 || dscp_value[num_dscp] >= 64)
            {
                cleanup();
                error("Invalid DSCP value");
            }
            else if (dscp_prob[num_dscp] < 0)
            {
                cleanup();
                error("Invalid DSCP probability value");
            }
            dscp_prob_total += dscp_prob[num_dscp];
            if (verbose_mode)
                printf("DSCP: %u, Prob: %u\n", dscp_value[num_dscp], dscp_prob[num_dscp]);
            num_dscp++;
        }
        else if (!strcmp(key, "rate"))
        {
            sscanf(line, "%s %uMbps %u", key, &rate_value[num_rate], &rate_prob[num_rate]);
            if (rate_value[num_rate] < 0)
            {
                cleanup();
                error("Invalid sending rate value");
            }
            else if (rate_prob[num_rate] < 0)
            {
                cleanup();
                error("Invalid sending rate probability value");
            }
            rate_prob_total += rate_prob[num_rate];
            if (verbose_mode)
                printf("Rate: %uMbps, Prob: %u\n", rate_value[num_rate], rate_prob[num_rate]);
            num_rate++;
        }
        else if (!strcmp(key, "threshold"))
        {
            sscanf(line, "%s %u", key, &thresholds[num_classes-1]);
            
            if (thresholds[num_classes-1] < 0)
            {
                cleanup();
                error("Invalid threshold");
            }

            if (verbose_mode)
                printf("Threshold: %u\n", thresholds[num_classes-1]);
            num_classes++;
        }
    }

    fclose(fd);

    /* by default, DSCP value is 0 */
    if (num_dscp == 0)
    {
        num_dscp = 1;
        dscp_value[0] = 0;
        dscp_prob[0] = 100;
        dscp_prob_total = dscp_prob[0];
        if (verbose_mode)
            printf("DSCP: %u, Prob: %u\n", dscp_value[0], dscp_prob[0]);
    }

    /* by default, no rate limiting */
    if (num_rate == 0)
    {
        num_rate = 1;
        rate_value[0] = 0;
        rate_prob[0] = 100;
        rate_prob_total = rate_prob[0];
        if (verbose_mode)
            printf("Rate: %uMbps, Prob: %u\n", rate_value[0], rate_prob[0]);
    }

    /* by default no thresholds */
    if(num_classes == 1){
        thresholds[0] = (int)INFINITY;
    }
}

/* set request variables */
void set_req_variables()
{
    int i = 0;
    unsigned long req_size_total = 0;
    unsigned long req_interval_total = 0;
    unsigned long rate_total = 0;
    double dscp_total = 0;

    /* calculate average request arrival interval */
    if (load > 0)
    {
        period_us = avg_cdf(req_size_dist) * 8 / load / TG_GOODPUT_RATIO;
        
        if (avg_cdf(req_size_dist) <= 0)
        {
            cleanup();
            error("Error: avg size is not positive");
        }
    }
    else
    {
        cleanup();
        error("Error: load is not positive");
    }

    /* transfer time to the number of requests */
    if (req_total_num == 0 && req_total_time > 0)
        req_total_num = max((unsigned long)req_total_time * 1000000 / period_us, 1);

    /* request variables */
    req_size = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_server_id = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_dscp = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_rate = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_sleep_us = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_start_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_stop_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_dispatch_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_done = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_seq = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_pause_us = (unsigned long long*)calloc(req_total_num, sizeof(unsigned long long));



    if (!req_size || !req_server_id || !req_dscp || !req_rate || !req_sleep_us || !req_start_time || !req_stop_time || !req_dispatch_time)
    {
        cleanup();
        error("Error: calloc per-request variables");
    }

    for (i = 0; i < req_total_num; i++)
    {
        req_size[i] = gen_random_cdf(req_size_dist);    /* flow size */
        req_server_id[i] = rand() % num_server; /* server ID */
        server_req_count[req_server_id[i]]++;   /* per-server request number */
        req_dscp[i] = gen_value_weight(dscp_value, dscp_prob, num_dscp, dscp_prob_total);    /* flow DSCP */
        req_rate[i] = gen_value_weight(rate_value, rate_prob, num_rate, rate_prob_total);   /* flow sending rate */
        req_sleep_us[i] = poission_gen_interval(1.0/period_us); /* sleep interval based on poission process */
        req_done[i] = 0; /* indicates whether flow request has been dispatched or not */
        req_seq[i] = -1; /* the sequence given by sequencer */
        req_size_total += req_size[i];
        req_interval_total += req_sleep_us[i];
        dscp_total += req_dscp[i];
        rate_total += req_rate[i];
    }

    printf("===========================================\n");
    printf("We generate %u requests in total\n", req_total_num);

    for (i = 0; i < num_server; i++)
        printf("%s:%u    %u requests\n", server_addr[i], server_port[i], server_req_count[i]);

    printf("===========================================\n");
    printf("The average request arrival interval is %lu us\n", req_interval_total/req_total_num);
    printf("The average request size is %lu bytes\n", req_size_total/req_total_num);
    printf("The average DSCP value is %.2f\n", dscp_total/req_total_num);
    printf("The average flow sending rate is %lu Mbps\n", rate_total/req_total_num);
    printf("The expected experiment duration is %lu s\n", req_interval_total/1000000);
}

/* set request variables from file */
void set_req_variables_file(char *file_name)
{

    int i = 0;
    unsigned long req_size_total = 0;
    unsigned long req_interval_total = 0;
    unsigned long rate_total = 0;
    double dscp_total = 0;


    FILE *fd = NULL;
    char line[256] = {0};
    unsigned int size;
    unsigned int start;
    unsigned int prev_start = 0;
    unsigned int num_flows = 0;

    fd = fopen(file_name,"r");
    
    if(!fd)
        error("Error: open configuration file for the first time");

    while (fgets(line, sizeof(line), fd) != NULL)
    {
        num_flows++;
    }

    fclose(fd);

    printf("Making %d flows\n", num_flows);
    req_total_num = num_flows;
    
    /* request variables */
    req_size = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_server_id = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_dscp = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_rate = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_sleep_us = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_start_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_stop_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_dispatch_time = (struct timeval*)calloc(req_total_num, sizeof(struct timeval));
    req_done = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_seq = (unsigned int*)calloc(req_total_num, sizeof(unsigned int));
    req_pause_us = (unsigned long long*)calloc(req_total_num, sizeof(unsigned long long));


    if (!req_size || !req_server_id || !req_dscp || !req_rate || !req_sleep_us || !req_start_time || !req_stop_time || !req_dispatch_time || !req_seq)
    {
        cleanup();
        error("Error: calloc per-request variables");
    }

    /* second time */
    i = 0;

    fd = fopen(file_name, "r");
    if (!fd)
    {
        cleanup();
        error("Error: open configuration file for the second time");
    }

    while (fgets(line, sizeof(line), fd) != NULL)
    {
        remove_newline(line);
        sscanf(line, "%u %u", &size, &start);
        req_size[i] = size;    /* flow size */
        req_server_id[i] = rand() % num_server; /* server ID */
        server_req_count[req_server_id[i]]++;   /* per-server request number */
        req_dscp[i] = 0;
        req_rate[i] = rate_value[0];   /* flow sending rate */
        req_done[i] = 0;
        req_seq[i] = -1;
        req_sleep_us[i] = start - prev_start;
        req_size_total += req_size[i];
        req_interval_total += req_sleep_us[i];
        dscp_total += req_dscp[i];
        rate_total += req_rate[i];
        prev_start = start;
        i++;
    }
    fclose(fd);


    /* calculate average request arrival interval */
    if (load > 0)
    {
        period_us = (double)(req_size_total/req_total_num) * 8 / (load) / TG_GOODPUT_RATIO;
        if (period_us <= 0)
        {
            cleanup();
            error("Error: period_us is not positive");
        }
    }
    else
    {
        cleanup();
        error("Error: load is not positive");
    }

    /* transfer time to the number of requests */
    if (req_total_num == 0 && req_total_time > 0)
        req_total_num = max((unsigned long)req_total_time * 1000000 / period_us, 1);


    printf("===========================================\n");
    printf("We generate %u requests in total\n", req_total_num);

    for (i = 0; i < num_server; i++)
        printf("%s:%u    %u requests\n", server_addr[i], server_port[i], server_req_count[i]);

    printf("===========================================\n");
    printf("The average request arrival interval is %lu us\n", req_interval_total/req_total_num);
    printf("The average request size is %lu bytes\n", req_size_total/req_total_num);
    printf("The average DSCP value is %.2f\n", dscp_total/req_total_num);
    printf("The average flow sending rate is %lu Mbps\n", rate_total/req_total_num);
    printf("The expected experiment duration is %lu s\n", req_interval_total/1000000);
}

/* receive traffic from established connections */
void *listen_connection(void *ptr)
{
    struct conn_node *node = (struct conn_node*)ptr;
    struct flow_metadata flow;
    char read_buf[TG_MAX_READ] = {0};
    unsigned int fc, idx;

    struct seq_msg smsg;

    while (true)
    {
        if (!read_flow_metadata(node->sockfd, &flow))
        {
            perror("Error: read meatadata");
            break;
        }

	//HM_Debug
        //fc = get_class(flow.size);
	idx = flow.id;
	fc = fs_info_list[idx].flowClass;
	
        if (read_exact(node->sockfd, read_buf, flow.size, TG_MAX_READ, true) != flow.size)
        {
            perror("Error: receive flow");
            break;
        }

        

        //if (req_completed%100 == 0)
        // printf("Flows compelted: %d\n",req_completed);

        /* a special flow ID to terminate persistent connection */
        if (flow.id == 0)
            break;
        else
            gettimeofday(&req_stop_time[flow.id - 1], NULL);

        /* broadcast finish of flow */
        if(use_seq && flow.id!=0 && isHeadBlocked(&dispatch_queues[fc])){
            smsg.seq = req_seq[flow.id-1];
            smsg.fc = fc;

            send_UDP_seq_msg("10.1.1.255", BROADCAST, send_fd, smsg);
            #ifdef BLOGGING
            printf("broadcasting on socket: %d\n", send_fd);
            printf("BROADCASTING: id: %u seq: %u\n", flow.id, smsg.seq);
            printf("=====================================\n");
            fprintf(log_fd, "BROADCASTING: id: %u seq: %u\n", flow.id, smsg.seq);
            fprintf(log_fd, "=====================================\n");
            #endif
        }

        pthread_mutex_lock(&(node->list->lock));

        /* not the special flow ID */
        if (flow.id != 0)
        {
            node->list->flow_finished++;
            node->list->available_len++;
            req_completed++;

        }

        /* Ohterwise, it's a special flow ID to terminate connection.
           So this connection will no longer be available. */
        pthread_mutex_unlock(&(node->list->lock));

        node->busy = false;

        sem_post(&(class_busy_mutex[fc]));
    }

    close(node->sockfd);
    node->connected = false;
    node->busy = false;
    // pthread_detach(pthread_self()); //musa: for virtual memory

    return (void*)0;
}

/* generate flow requests */
void run_requests()
{
    unsigned int i = 0;
    unsigned int k = 1;
    unsigned int sleep_us = 0;

    for (i = 0; i < req_total_num; i++)
    {
        sleep_us += req_sleep_us[i];
        if (sleep_us > usleep_overhead_us)
        {
            usleep(sleep_us - usleep_overhead_us);
            sleep_us = 0;
        }

        /* Send request and record start time */
        gettimeofday(&req_start_time[i], NULL);
        req_generated++;
        classify_flow(i);

        if (!verbose_mode && i + 1 >= k * req_total_num / 100)
        {
            // display_progress(i + 1, req_total_num);
            k++;
        }
    }
    if (!verbose_mode)
        printf("\n");
}

void classify_flow(unsigned int i){
	unsigned int fc = get_class(req_size[i]);

	//HM_Debug:
	fs_info_list[i+1].flowID = i+1;
	fs_info_list[i+1].flowClass = fc;
	fs_info_list[i+1].flowSize = req_size[i];

    enqueue(&dispatch_queues[fc], (struct queue_data){.id = i, .blocking=true, .batch_seq=-1, .batch_start=false, .batch_end=false});
    sem_post(&(dispatch_queues[fc].sem_mutex));
    // printf("DEBUG: flow size %u sent to class %u\n",req_size[i],fc);
    tsEnqueue(controller_queue,&req_size[i]);
}

void run_request(unsigned int req_id)
{
    unsigned int server_id = req_server_id[req_id];
    int sockfd;
    struct flow_metadata flow;
    struct conn_node* node = search_conn_list(&connection_lists[server_id]);
    unsigned int active_connections = 0;
    unsigned int i = 0;

    flow.id = req_id + 1;   /* we reserve flow ID 0 for special usage */
    flow.size = req_size[req_id];

//HM_Deb here
    flow.tos = get_tos(flow.size);
    flow.rate = 0;

    /* cannot find available connection. Need to establish new connections. */
    if (!node)
    {
        if (insert_conn_list(&connection_lists[server_id], 1))
        {
            node = connection_lists[server_id].tail;
            if (verbose_mode)
                printf("[%u] Establish a new connection to %s:%u (available/total = %u/%u)\n", ++num_new_conn, server_addr[server_id], server_port[server_id], node->list->available_len, node->list->len);
            pthread_create(&(node->thread), NULL, listen_connection, (void*)node);
        }
        else
        {
            if (verbose_mode)
                printf("Cannot establish a new connection to %s:%u\n", server_addr[server_id], server_port[server_id]);
            return;
        }
    }

    if (verbose_mode && (req_id % 100 == 0))
    {
        active_connections = 0;
        for (i = 0; i< num_server; i++)
            active_connections += connection_lists[i].len - connection_lists[i].available_len;
        printf("Concurrent active connections: %u\n", active_connections);
    }

    /* Send request and record dispatch time */
    gettimeofday(&req_dispatch_time[req_id],NULL);

    #ifdef DEBUG
    printf("Dispatching request. ID:%d Size:%d Class:%d tos:%d\n",req_id,flow.size,fc,flow.tos);
    #endif

    sockfd = node->sockfd;
    node->busy = true;
    pthread_mutex_lock(&(node->list->lock));
    node->list->available_len--;
    pthread_mutex_unlock(&(node->list->lock));

    if (!write_flow_req(sockfd, &flow))
        perror("Error: generate request");
}

/* run broad cast manager */
void *run_broadcast_manager(void *ptr){
    struct seq_msg smsg;
    unsigned int fc;
    FILE *fd;
    fd = fopen("broadcast.log","w");
    while(1)
    {        
        recv_UDP_seq_msg(recv_fd, &smsg);
        fc = smsg.fc;
        fprintf(fd,"Flow Class:%d\n",fc);
        fprintf(fd,"Length of sequencing_queues: %d\n",len(&sequencing_queues[fc]));
        fprintf(fd,"======================\n");
        enqueue(&sequencing_queues[fc], (struct queue_data){.id = 0, .blocking=false, .batch_seq=smsg.seq+1, .batch_start=false, .batch_end=false});
        sem_post(&(sequencing_queues[fc].sem_mutex));
    }
    fclose(fd);
}

/* scheduler */
void *run_scheduler(void *ptr)
{

    unsigned int fc = *((unsigned int *) ptr);
    free(ptr);
    ptr=NULL;

    // #ifdef STARTTEST
    // printf("Start test: scheduler started. class: %d\n", fc);
    // #endif

    printf("DEBUG Start test: scheduler started. class: %d\n", fc);

    struct queue_data *tmp;
    struct seq_msg smsg;
    unsigned int batch_size;
    
    while(1){
        sem_wait(&(dispatch_queues[fc].sem_mutex));
        sem_wait(&(class_busy_mutex[fc]));
        tmp = dequeue(&dispatch_queues[fc]);
        if(tmp!=NULL){

        	/* insert logic to go to sequencer */
            if(use_seq && tmp->blocking){
                get_seq(tmp->id, &smsg);
                req_seq[tmp->id] = smsg.seq;
                if(use_batching){
                    batch_size = get_batch_size(req_size[tmp->id]);
                    unblockTopK(&(dispatch_queues[fc]), batch_size, req_seq[tmp->id]);    
                }
            }
            req_seq[tmp->id] = smsg.seq;
            run_request(tmp->id);
        }
        else{
            printf("DEBUG scheduler: tmp shouldn't be NULL\n");
        }
    }
    return (void*)0;
}

/*  get seq number from sequencer - uses TCP*/
bool get_seq(unsigned int req_id, struct seq_msg *smsg)
{

    struct flow_metadata flow;
    flow.id = req_id + 1;
    flow.size = req_size[req_id];
    flow.tos = 0;
    flow.rate = 0;

    unsigned int fc = get_class(flow.size);
    flow.tos = fc;

    /* Each class has its own connection to the sequencer*/
    struct conn_node *node = get_node_by_index(&sequencer_conns, fc);
    char buf[SEQ_MSG_SIZE] = {0};
    
    /* Sending flow req to sequencer */
    if (!write_flow_req(node->sockfd, &flow)){
        perror("Error: generate request");
        return false;
    }

    /* Reading response from sequencer */
    if (read_exact(node->sockfd, buf, SEQ_MSG_SIZE, SEQ_MSG_SIZE, false) != SEQ_MSG_SIZE)
    {
        perror("Error: receive flow seq");
        return false;
    }

    buf2seq_msg(buf, smsg);
    struct queue_data *tmp;

    /* no need to wait if sequencer says go */
    if(smsg->seq == smsg->active)
        return true;
    else
        // printf("DEBUG: my seq: %u active: %u\n",smsg->seq,smsg->active);
    
    while(1){
        sem_wait(&(sequencing_queues[fc].sem_mutex));
        tmp = dequeue(&sequencing_queues[fc]);
        #ifdef LOGGING
        fprintf(log_fd,"DEBUG: Flow class: %d\n", fc);
        fprintf(log_fd,"DEBUG: My seq: %d active: %d\n", smsg->seq, tmp->batch_seq);
        fprintf(log_fd,"DEBUG: Getting Sequence. Length of sequence queue: %d\n", len(&sequencing_queues[fc]));
        fprintf(log_fd,"DEBUG: Getting Sequence. Length of dispatch queue: %d\n", len(&dispatch_queues[fc]));
        fprintf(log_fd,"Requests completed: %u Progress: %u%%\n",req_completed,(100*req_completed)/req_generated);
        fprintf(log_fd,"============================\n");
        #endif
        
        if(tmp!=NULL){
            if(tmp->batch_seq == smsg->seq){
                break;
            }
        }
        else{
            printf("DEBUG get seq: tmp shouldn't be NULL\n");
        }
    }
    return true;
}

/* Terminate all existing connections */
void exit_connections()
{
    unsigned int i = 0;
    struct conn_node *ptr = NULL;
    unsigned int num = 0;

    /* Start threads to receive traffic */
    for (i = 0; i < num_server; i++)
    {
        num = 0;
        ptr = connection_lists[i].head;
        while (true)
        {
            if (!ptr)
                break;
            else
            {
                if (ptr->connected)
                {
                    exit_connection(ptr);
                    num++;
                }
                ptr = ptr->next;
            }
        }
        wait_conn_list(&connection_lists[i]);
        if (verbose_mode)
            printf("Exit %u/%u connections to %s:%u\n", num, connection_lists[i].len, server_addr[i], server_port[i]);
    }
}

/* Terminate a connection */
void exit_connection(struct conn_node *node)
{
    int sockfd;
    struct flow_metadata flow;
    flow.id = 0;   /* a special flow ID to terminate connection */
    flow.size = 100;
    flow.tos = 0;
    flow.rate = 0;

    if (!node)
        return;

    sockfd = node->sockfd;
    pthread_mutex_lock(&(node->list->lock));
    node->list->available_len--;
    pthread_mutex_unlock(&(node->list->lock));

    if (!write_flow_req(sockfd, &flow))
        perror("Error: generate request");
}

void print_statistic()
{
    unsigned long long duration_us = (tv_end.tv_sec - tv_start.tv_sec) * 1000000 + tv_end.tv_usec - tv_start.tv_usec;
    unsigned long long req_size_total = 0;
    unsigned long long fct_us;
    unsigned int goodput_mbps; /* total goodput (Mbps) */
    unsigned int i = 0;
    FILE *fd = NULL;

    fd = fopen(fct_log_name, "w");
    if (!fd)
        error("Error: open the FCT result file");

    fprintf(fd, "start:%llu end:%llu\n", timeval2us(tv_start), timeval2us(tv_end));

    for (i = 0; i < req_total_num; i++)
    {
        req_size_total += req_size[i];
        if ((req_stop_time[i].tv_sec == 0) && (req_stop_time[i].tv_usec == 0))
        {
            printf("Unfinished flow request %u\n", i);
            continue;
        }

        fct_us = (req_stop_time[i].tv_sec - req_start_time[i].tv_sec) * 1000000 + req_stop_time[i].tv_usec - req_start_time[i].tv_usec;
        
        /*
        if (fct_us > 0)
            flow_goodput_mbps = req_size[i] * 8 / fct_us;
        else
            flow_goodput_mbps = 0;
        */

        /* size (bytes), FCT(us), DSCP, sending rate (Mbps), goodput (Mbps) */
        fprintf(fd, "%u %llu %llu %llu %llu %llu %llu\n", req_size[i], fct_us, timeval2us(req_start_time[i]), timeval2us(req_dispatch_time[i]), timeval2us(req_stop_time[i]), req_pause_us[i],
        req_size[i]*8/fct_calc(req_dispatch_time[i],req_stop_time[i]));

            /*
            fprintf(fd, "%u %llu %u %u %u %ld %ld\n", req_size[i], fct_us, req_dscp[i], req_rate[i], flow_goodput_mbps, \
             (req_start_time[i].tv_sec* 1000000) + req_start_time[i].tv_usec, \
             (req_stop_time[i].tv_sec * 1000000) + req_stop_time[i].tv_usec);
            */
    }

    fclose(fd);
    goodput_mbps = req_size_total * 8 / duration_us;
    printf("The actual RX throughput is %u Mbps\n", (unsigned int)(goodput_mbps/TG_GOODPUT_RATIO));
    printf("The actual duration is %llu s\n", duration_us/1000000);
    printf("Write FCT results to %s\n", fct_log_name);
    printf("===========================================\n");

    fprintf(log_fd,"The actual RX throughput is %u Mbps\n", (unsigned int)(goodput_mbps/TG_GOODPUT_RATIO));
    fprintf(log_fd,"The actual duration is %llu s\n", duration_us/1000000);
    fprintf(log_fd,"Write FCT results to %s\n", fct_log_name);
    fprintf(log_fd,"===========================================\n");
}

/* clean up resources */
void cleanup()
{
    unsigned int i = 0;

    free(server_port);
    free(server_addr);
    free(server_req_count);

    free(dscp_value);
    free(dscp_prob);

    free(rate_value);
    free(rate_prob);

    free_cdf(req_size_dist);
    free(req_size_dist);

    free(req_size);
    free(req_server_id);
    free(req_dscp);
    free(req_rate);
    free(req_sleep_us);
    free(req_start_time);
    free(req_stop_time);
    free(req_dispatch_time);

    free(req_pause_us);
    free(req_done);
    free(req_seq);

    if (connection_lists)
    {
        if (verbose_mode)
            printf("===========================================\n");

        for(i = 0; i < num_server; i++)
        {
            if (verbose_mode)
                printf("Clear connection list %u to %s:%u\n", i, connection_lists[i].ip, connection_lists[i].port);
            clear_conn_list(&connection_lists[i]);
        }
    }
    free(connection_lists);
}

// HM_Debug
int get_class(int size){
    
    int i;
    if(scheme!=3){
        return 0;
    }
    
    for(i=0;i<num_classes-1;i++){
        if(size<=thresholds[i]){
	    
            return i;
        }
    }

    return num_classes-1;
}

int get_tos(int size){	
	
    int fc = get_class(size);
    int i;
    for(i=0;i<num_classes;i++){
        if(fc==i){
            return tos_map[i];
        }
    }

    return tos_map[num_classes-1];
}

unsigned int get_batch_size(unsigned int flowsize){
    struct Queue *tqueue = &dispatch_queues[get_class(flowsize)];
    
    struct Node *curr = tqueue->head;
    unsigned int i = 0;
    unsigned int curr_batch_size = flowsize;
    while(curr != NULL){
        if(curr_batch_size > max_batch_size)
            return i;
        curr_batch_size += req_size[curr->data.id];

        curr=curr->next;
        i++;
    }
    return i;
}

void init_seq_conns(){
    if (!init_conn_list(&sequencer_conns, 0, seq_addr, seq_port))
    {
        cleanup();
        error("Error: init_conn_list for sequencer");
    }
    /* establish # of classes worth connection to seq_addr:seq_port */
    if (!insert_conn_list(&sequencer_conns, num_classes))
    {
        cleanup();
        error("Error: insert_conn_list for sequencer");
    }
}

bool init_schedulers(){

	// struct Queue *dispatch_queues = NULL;
	// sem_t *class_busy_mutex = NULL;
	// pthread_t *schedulers = NULL;

    /* initializing scheduler vars */
	
    unsigned int i;

    dispatch_queues = calloc(num_classes, sizeof(struct Queue));
    schedulers = calloc(num_classes, sizeof(pthread_t));
    class_busy_mutex = calloc(num_classes, sizeof(sem_t));

    if( !dispatch_queues || !schedulers || !class_busy_mutex ) {
    	perror("calloc");
    	return false;
    }

    for (i = 0; i < num_classes; i++){
    	unsigned int *fcptr = malloc(sizeof(unsigned int));
        *fcptr = i;
        create_queue(&dispatch_queues[i]);
        // if(i==0)
        //     sem_init(&(class_busy_mutex[i]),0,100);
        // else
        //     sem_init(&(class_busy_mutex[i]),0,5);
        /*if(i==0 && scheme==3)
            sem_init(&(class_busy_mutex[i]),0,5);
        else*/
            sem_init(&(class_busy_mutex[i]),0,1);
        // sem_post(&(class_busy_mutex[i]));
        pthread_create(&(schedulers[i]), NULL, run_scheduler, (void *)fcptr);
    }
    
    return true;
}

bool init_broadcast_manager(){
	// struct Queue *sequencing_queues = NULL;
	// pthread_t broadcast_manager;

	unsigned int i;

    sequencing_queues = calloc(num_classes, sizeof(struct Queue));

    if( !sequencing_queues) {
    	perror("calloc");
    	return false;
    }

    for (i = 0; i < num_classes; i++){
        create_queue(&sequencing_queues[i]);
    }

    pthread_create(&(broadcast_manager), NULL, run_broadcast_manager, (void *)NULL);
    return true;
}
